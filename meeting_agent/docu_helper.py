"""
Document Helper Module

Provides functionality to save LLM-generated content in multiple document formats
(txt, docx, rtf, md) with APA 7th edition citations for AI-generated content.
Uses mimetypes for format detection and validation.
"""

import mimetypes
import re
from enum import Enum
from pathlib import Path
from typing import Any

from meeting_agent.helper import sanitize_path_for_logging, write_instrumentation_log

try:
    from docx import Document as DocxDocument

    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False

try:
    from PyRTF.document.paragraph import Cell, Paragraph, Table
    from PyRTF.Elements import Document as RtfDocument
    from PyRTF.Elements import Section, Text, TextPropertySet
    from PyRTF.Renderer import Renderer

    PYRTF3_AVAILABLE = True
except ImportError:
    PYRTF3_AVAILABLE = False
    # PyRTF3 is used for RTF generation (modern, Python 3 compatible library)


class DocumentFormat(Enum):
    """Supported document formats."""

    TXT = "txt"
    DOCX = "docx"
    RTF = "rtf"
    MD = "md"


def get_mimetype(extension: str) -> str:
    """Get MIME type for a file extension.

    Args:
        extension: File extension (with or without leading dot).

    Returns:
        str: MIME type string, or 'application/octet-stream' if unknown.
    """
    if not extension.startswith("."):
        extension = "." + extension

    mimetype, _ = mimetypes.guess_type(f"file{extension}")
    return mimetype or "application/octet-stream"


def generate_apa_citation(
    model_name: str = "gpt-oss:120b", version: str = "2024", url: str = "https://ollama.com"
) -> str:
    """Generate APA 7th edition citation for AI-generated content.

    Args:
        model_name: Name of the AI model used (e.g., "gpt-oss:120b").
        version: Version or year of the model (defaults to "2024").
        url: URL where the model is accessed (defaults to "https://ollama.com").

    Returns:
        str: Formatted APA citation section.
    """
    return f"""

---

## References

**Note:** This document was generated by AI and validated by the user.

Ollama. ({version}). {model_name} ({version} version) [Large language model]. {url}

**In-text citation format:** (Ollama, {version})
"""


def _strip_markdown(text: str) -> str:
    """Strip markdown formatting from text.

    Args:
        text: Markdown-formatted text.

    Returns:
        str: Plain text with markdown removed.
    """
    # Remove headers
    text = re.sub(r"^#+\s+", "", text, flags=re.MULTILINE)
    # Remove bold/italic
    text = re.sub(r"\*\*([^*]+)\*\*", r"\1", text)
    text = re.sub(r"\*([^*]+)\*", r"\1", text)
    # Remove links
    text = re.sub(r"\[([^\]]+)\]\([^\)]+\)", r"\1", text)
    # Remove horizontal rules
    text = re.sub(r"^---+$", "", text, flags=re.MULTILINE)
    # Remove list markers
    text = re.sub(r"^\s*[-*+]\s+", "", text, flags=re.MULTILINE)
    text = re.sub(r"^\s*\d+\.\s+", "", text, flags=re.MULTILINE)
    # Remove table formatting
    text = re.sub(r"\|", " ", text)
    text = re.sub(r"-{3,}", "", text)
    # Clean up extra whitespace
    text = re.sub(r"\n{3,}", "\n\n", text)
    text = re.sub(r" {2,}", " ", text)

    return text.strip()


def _parse_markdown_to_docx(doc: DocxDocument, markdown_text: str) -> None:
    """Parse markdown text and add formatted content to Word document.

    Args:
        doc: python-docx Document object.
        markdown_text: Markdown-formatted text to parse.
    """
    lines = markdown_text.split("\n")
    i = 0

    while i < len(lines):
        line = lines[i].strip()

        if not line:
            i += 1
            continue

        # Headers
        if line.startswith("# "):
            p = doc.add_heading(line[2:].strip(), level=1)
        elif line.startswith("## "):
            p = doc.add_heading(line[3:].strip(), level=2)
        elif line.startswith("### "):
            p = doc.add_heading(line[4:].strip(), level=3)
        elif line.startswith("#### "):
            p = doc.add_heading(line[5:].strip(), level=4)
        elif line.startswith("##### "):
            p = doc.add_heading(line[6:].strip(), level=5)
        elif line.startswith("###### "):
            p = doc.add_heading(line[7:].strip(), level=6)
        # Horizontal rule
        elif line.startswith("---"):
            p = doc.add_paragraph()
            p.add_run("─" * 50).bold = True
        # Tables (simple detection)
        elif "|" in line and i + 1 < len(lines) and "|" in lines[i + 1]:
            # Create a simple table
            table_data = []
            while i < len(lines) and "|" in lines[i]:
                row = [cell.strip() for cell in lines[i].split("|") if cell.strip()]
                if row and not all(c == "-" for c in "".join(row)):
                    table_data.append(row)
                i += 1
            i -= 1  # Adjust for loop increment

            if table_data:
                # #region agent log
                write_instrumentation_log(
                    location="DocuHelper.py:163",
                    message="Before table creation",
                    data={
                        "table_data_count": len(table_data),
                        "first_row_cols": len(table_data[0]) if table_data else 0,
                        "all_row_lengths": [len(r) for r in table_data],
                    },
                    hypothesis_id="A",
                )
                # #endregion
                table = doc.add_table(rows=len(table_data), cols=len(table_data[0]))
                # Apply table style with borders
                table.style = "Light Grid Accent 1"  # This style includes borders

                for row_idx, row_data in enumerate(table_data):
                    # #region agent log
                    write_instrumentation_log(
                        location="DocuHelper.py:168",
                        message="Processing table row",
                        data={
                            "row_idx": row_idx,
                            "row_cols": len(row_data),
                            "expected_cols": len(table_data[0]),
                        },
                        hypothesis_id="A",
                    )
                    # #endregion
                    for col_idx, cell_data in enumerate(row_data):
                        if col_idx < len(table_data[0]):
                            cell = table.rows[row_idx].cells[col_idx]
                            # #region agent log
                            write_instrumentation_log(
                                location="DocuHelper.py:171",
                                message="Before cell paragraph access",
                                data={
                                    "cell_paragraphs_count": len(cell.paragraphs)
                                    if hasattr(cell, "paragraphs")
                                    else 0
                                },
                                hypothesis_id="E",
                            )
                            # #endregion
                            # Clear default paragraph and add formatted text
                            cell.paragraphs[0].clear()
                            # Parse markdown formatting in cell content
                            _add_formatted_text(cell.paragraphs[0], cell_data)
                            # Make header row bold
                            if row_idx == 0:
                                for paragraph in cell.paragraphs:
                                    for run in paragraph.runs:
                                        run.bold = True
        # Lists
        elif line.startswith(("- ", "* ", "+ ")):
            p = doc.add_paragraph(line[2:].strip(), style="List Bullet")
        elif re.match(r"^\d+\.\s+", line):
            p = doc.add_paragraph(re.sub(r"^\d+\.\s+", "", line), style="List Number")
        # Regular paragraph with formatting
        else:
            p = doc.add_paragraph()
            _add_formatted_text(p, line)

        i += 1


def _add_formatted_text(paragraph, text: str) -> None:
    """Add text with markdown formatting to a paragraph.

    Args:
        paragraph: python-docx paragraph object.
        text: Text that may contain markdown formatting.
    """
    if not text:
        return

    # More comprehensive markdown parsing
    # Handle bold (**text** or __text__) - match non-greedy to handle multiple bold sections
    # Handle italic (*text* or _text_) - but not if part of bold
    # Use non-greedy matching to handle cases like "**Vendor A:** text **Vendor B:**"

    # First, handle bold (**text** or __text__)
    # Pattern: ** followed by non-* chars (non-greedy) followed by **
    # Or: __ followed by non-_ chars (non-greedy) followed by __
    text = re.sub(r"\*\*([^*]+?)\*\*", lambda m: f"<BOLD>{m.group(1)}</BOLD>", text)
    text = re.sub(r"__([^_]+?)__", lambda m: f"<BOLD>{m.group(1)}</BOLD>", text)

    # Then handle italic (*text* or _text_) - but not if it's part of a bold marker
    # Pattern: * not followed by * and not preceded by *, then non-* chars, then *
    text = re.sub(r"(?<!\*)\*([^*]+?)\*(?!\*)", lambda m: f"<ITALIC>{m.group(1)}</ITALIC>", text)
    text = re.sub(r"(?<!_)_([^_]+?)_(?!_)", lambda m: f"<ITALIC>{m.group(1)}</ITALIC>", text)

    # Now split by our markers and process
    parts = re.split(r"(<BOLD>.*?</BOLD>|<ITALIC>.*?</ITALIC>)", text)

    for part in parts:
        if not part:
            continue
        if part.startswith("<BOLD>") and part.endswith("</BOLD>"):
            run = paragraph.add_run(part[6:-7])  # Remove <BOLD> and </BOLD>
            run.bold = True
        elif part.startswith("<ITALIC>") and part.endswith("</ITALIC>"):
            run = paragraph.add_run(part[8:-9])  # Remove <ITALIC> and </ITALIC>
            run.italic = True
        else:
            # Regular text - add as is
            paragraph.add_run(part)


def _parse_markdown_to_rtf_document(markdown_text: str) -> RtfDocument:
    """Parse markdown text and create PyRTF3 Document.

    Args:
        markdown_text: Markdown-formatted text.

    Returns:
        RtfDocument: PyRTF3 Document object.
    """
    if not PYRTF3_AVAILABLE:
        raise ImportError("PyRTF3 is required for RTF format. Install it with: pip install pyrtf3")

    doc = RtfDocument()
    section = Section()

    lines = markdown_text.split("\n")
    i = 0

    while i < len(lines):
        line = lines[i].strip()

        if not line:
            # Add empty paragraph for spacing
            p = Paragraph()
            section.append(p)
            i += 1
            continue

        # Headers
        if line.startswith("# "):
            text = line[2:].strip()
            props = TextPropertySet(bold=True, size=24)
            p = Paragraph()
            p.append(Text(text, props))
            section.append(p)
        elif line.startswith("## "):
            text = line[3:].strip()
            props = TextPropertySet(bold=True, size=22)
            p = Paragraph()
            p.append(Text(text, props))
            section.append(p)
        elif line.startswith("### "):
            text = line[4:].strip()
            props = TextPropertySet(bold=True, size=20)
            p = Paragraph()
            p.append(Text(text, props))
            section.append(p)
        elif line.startswith("#### "):
            text = line[5:].strip()
            props = TextPropertySet(bold=True, size=18)
            p = Paragraph()
            p.append(Text(text, props))
            section.append(p)
        elif line.startswith("##### "):
            text = line[6:].strip()
            props = TextPropertySet(bold=True, size=16)
            p = Paragraph()
            p.append(Text(text, props))
            section.append(p)
        elif line.startswith("###### "):
            text = line[7:].strip()
            props = TextPropertySet(bold=True, size=14)
            p = Paragraph()
            p.append(Text(text, props))
            section.append(p)
        # Horizontal rule
        elif line.startswith("---"):
            p = Paragraph()
            p.append(Text("─" * 50, TextPropertySet(bold=True)))
            section.append(p)
        # Tables (parse markdown table and create RTF table)
        elif "|" in line and i + 1 < len(lines) and "|" in lines[i + 1]:
            # Collect all table rows (including header)
            table_rows = []
            while i < len(lines) and "|" in lines[i]:
                row = lines[i].strip()
                # Skip separator rows (all dashes, pipes, colons, spaces)
                if not all(c in "|-: " for c in row):
                    # Parse cells (split by |, remove empty cells at edges)
                    cells = [cell.strip() for cell in row.split("|")]
                    # Remove empty cells at start/end (markdown tables often have them)
                    if cells and not cells[0]:
                        cells = cells[1:]
                    if cells and not cells[-1]:
                        cells = cells[:-1]
                    if cells:
                        table_rows.append(cells)
                i += 1
            i -= 1  # Adjust for loop increment

            # Create RTF table if we have rows
            if table_rows:
                # Determine number of columns from first row
                num_cols = len(table_rows[0]) if table_rows else 0
                if num_cols > 0:
                    # Create table with equal column widths (in twips: 1 inch = 1440 twips)
                    col_width = int(6000 / num_cols)  # Distribute 6000 twips across columns
                    table = Table(*[col_width] * num_cols)

                    # Add rows to table
                    for row_idx, row_cells in enumerate(table_rows):
                        # Pad row if needed
                        while len(row_cells) < num_cols:
                            row_cells.append("")
                        # Truncate if too many cells
                        row_cells = row_cells[:num_cols]

                        # Create Cell objects with text
                        rtf_cells = []
                        for cell_text in row_cells:
                            # #region agent log
                            write_instrumentation_log(
                                location="DocuHelper.py:349",
                                message="RTF table cell text",
                                data={
                                    "cell_text": cell_text[:50],
                                    "has_markdown": "**" in cell_text or "__" in cell_text,
                                },
                                hypothesis_id="C",
                            )
                            # #endregion
                            # First row is typically header - make it bold
                            if row_idx == 0:
                                cell = Cell(Text(cell_text, TextPropertySet(bold=True)))
                            else:
                                cell = Cell(Text(cell_text))
                            rtf_cells.append(cell)

                        table.AddRow(*rtf_cells)

                    section.append(table)
        # Lists
        elif line.startswith(("- ", "* ", "+ ")):
            text = line[2:].strip()
            p = Paragraph()
            p.append(Text(f"• {text}"))
            section.append(p)
        elif re.match(r"^\d+\.\s+", line):
            text = re.sub(r"^\d+\.\s+", "", line)
            p = Paragraph()
            p.append(Text(text))
            section.append(p)
        # Bold/italic text in paragraph
        elif "**" in line or "*" in line:
            # Parse inline formatting
            parts = re.split(r"(\*\*[^*]+\*\*|\*[^*]+\*)", line)
            p = Paragraph()
            for part in parts:
                if part.startswith("**") and part.endswith("**"):
                    # Bold text
                    p.append(Text(part[2:-2], TextPropertySet(bold=True)))
                elif part.startswith("*") and part.endswith("*") and not part.startswith("**"):
                    # Italic text
                    p.append(Text(part[1:-1], TextPropertySet(italic=True)))
                elif part:
                    # Regular text
                    p.append(Text(part))
            section.append(p)
        # Regular paragraph
        else:
            p = Paragraph()
            p.append(Text(line))
            section.append(p)

        i += 1

    doc.Sections.append(section)
    return doc


def _save_as_txt(content: str, output_path: Path, citation: str) -> Path:
    """Save content as plain text file.

    Args:
        content: Markdown-formatted content.
        output_path: Path where file should be saved.
        citation: APA citation to append.

    Returns:
        Path: Path to saved file.
    """
    # Strip markdown formatting
    plain_text = _strip_markdown(content)

    # Append citation
    full_content = plain_text + citation

    # Write file
    output_path.write_text(full_content, encoding="utf-8")

    return output_path


def _save_as_docx(content: str, output_path: Path, citation: str) -> Path:
    """Save content as Word document.

    Args:
        content: Markdown-formatted content.
        output_path: Path where file should be saved.
        citation: APA citation to append.

    Returns:
        Path: Path to saved file.

    Raises:
        ImportError: If python-docx is not installed.
    """
    if not DOCX_AVAILABLE:
        raise ImportError(
            "python-docx is required for DOCX format. Install it with: pip install python-docx"
        )

    doc = DocxDocument()

    # Parse markdown content
    _parse_markdown_to_docx(doc, content)

    # Add citation section
    citation_lines = citation.split("\n")
    for line in citation_lines:
        # #region agent log
        write_instrumentation_log(
            location="DocuHelper.py:449",
            message="Processing citation line",
            data={
                "line": line[:60],
                "starts_with_##": line.startswith("##"),
                "starts_with_**": line.startswith("**"),
                "has_markdown_middle": "**" in line[2:] if len(line) > 2 else False,
            },
            hypothesis_id="D",
        )
        # #endregion
        if line.strip():
            if line.startswith("##"):
                doc.add_heading(line.replace("#", "").strip(), level=2)
            elif line.startswith("**"):
                p = doc.add_paragraph()
                # Use proper markdown parsing instead of simple replace
                _add_formatted_text(p, line)
            else:
                p = doc.add_paragraph()
                _add_formatted_text(p, line)

    doc.save(str(output_path))

    return output_path


def _save_as_rtf(content: str, output_path: Path, citation: str) -> Path:
    """Save content as RTF file using PyRTF3.

    Args:
        content: Markdown-formatted content.
        output_path: Path where file should be saved.
        citation: APA citation to append.

    Returns:
        Path: Path to saved file.

    Raises:
        ImportError: If PyRTF3 is not installed.
    """
    if not PYRTF3_AVAILABLE:
        raise ImportError("PyRTF3 is required for RTF format. Install it with: pip install pyrtf3")

    # Create document from markdown content
    doc = _parse_markdown_to_rtf_document(content)

    # Add citation section
    citation_section = Section()
    citation_lines = citation.split("\n")

    for line in citation_lines:
        line = line.strip()
        if not line:
            p = Paragraph()
            citation_section.append(p)
            continue

        p = Paragraph()
        # Headers
        if line.startswith("##"):
            text = line.replace("#", "").strip()
            p.append(Text(text, TextPropertySet(bold=True, size=20)))
        # Bold/italic text in paragraph - parse markdown properly
        elif "**" in line or "*" in line:
            # Parse inline formatting similar to _parse_markdown_to_rtf_document
            parts = re.split(r"(\*\*[^*]+\*\*|\*[^*]+\*)", line)
            for part in parts:
                if part.startswith("**") and part.endswith("**"):
                    # Bold text
                    p.append(Text(part[2:-2], TextPropertySet(bold=True)))
                elif part.startswith("*") and part.endswith("*") and not part.startswith("**"):
                    # Italic text
                    p.append(Text(part[1:-1], TextPropertySet(italic=True)))
                elif part:
                    # Regular text
                    p.append(Text(part))
        # Regular text
        else:
            p.append(Text(line))
        citation_section.append(p)

    doc.Sections.append(citation_section)

    # Write RTF file (PyRTF3 expects text mode)
    with open(output_path, "w", encoding="utf-8") as f:
        Renderer().Write(doc, f)

    return output_path


def _save_as_md(content: str, output_path: Path, citation: str) -> Path:
    """Save content as markdown file.

    Args:
        content: Markdown-formatted content.
        output_path: Path where file should be saved.
        citation: APA citation to append.

    Returns:
        Path: Path to saved file.
    """
    # Append citation to markdown
    full_content = content + citation

    # Write file
    output_path.write_text(full_content, encoding="utf-8")

    return output_path


def _prompt_format() -> DocumentFormat:
    """Interactive prompt for format selection.

    Returns:
        DocumentFormat: Selected format.
    """
    print("\nSelect document format:")
    print("  1. Plain Text (.txt)")
    print("  2. Word Document (.docx)")
    print("  3. Rich Text Format (.rtf)")
    print("  4. Markdown (.md)")

    while True:
        try:
            choice = input("\nEnter choice (1-4): ").strip()
            if choice == "1":
                return DocumentFormat.TXT
            if choice == "2":
                return DocumentFormat.DOCX
            if choice == "3":
                return DocumentFormat.RTF
            if choice == "4":
                return DocumentFormat.MD
            print("Invalid choice. Please enter 1, 2, 3, or 4.")
        except (EOFError, KeyboardInterrupt):
            # Default to markdown on interrupt
            print("\nDefaulting to Markdown format.")
            return DocumentFormat.MD


def save_document(
    content: str,
    output_path: Path,
    format: DocumentFormat | None = None,
    interactive: bool = True,
    model_info: dict[str, Any] | None = None,
) -> Path:
    # #region agent log
    write_instrumentation_log(
        location="DocuHelper.py:573",
        message="save_document entry",
        data={
            "content_length": len(content) if content else 0,
            "content_is_none": content is None,
            "content_is_empty": content == "" if content else True,
            "output_path": sanitize_path_for_logging(output_path),
            "format": str(format),
        },
        hypothesis_id="F",
    )
    # #endregion
    """Save document in specified format with APA citation.

    Args:
        content: Markdown-formatted content to save.
        output_path: Path where file should be saved (extension may be added/changed).
        format: Document format to use. If None and interactive=True, prompts user.
        interactive: If True and format is None, prompt user for format selection.
        model_info: Dictionary with model information for APA citation.
            Keys: 'model_name', 'version', 'url'. Defaults to Ollama values.

    Returns:
        Path: Path to saved file.

    Raises:
        ValueError: If format is invalid or cannot be determined.
        ImportError: If required library is missing for selected format.
    """
    # Determine format
    if format is None:
        if interactive:
            format = _prompt_format()
        else:
            # Try to determine from file extension
            ext = output_path.suffix.lstrip(".")
            if ext == "txt":
                format = DocumentFormat.TXT
            elif ext == "docx":
                format = DocumentFormat.DOCX
            elif ext == "rtf":
                format = DocumentFormat.RTF
            elif ext == "md" or ext == "":
                format = DocumentFormat.MD
            else:
                raise ValueError(f"Cannot determine format from extension: {ext}")

    # Ensure output path has correct extension
    if output_path.suffix.lstrip(".") != format.value:
        output_path = output_path.with_suffix("." + format.value)

    # Validate mimetype
    expected_mimetype = get_mimetype(format.value)
    actual_mimetype = get_mimetype(output_path.suffix.lstrip("."))
    if expected_mimetype != actual_mimetype and actual_mimetype != "application/octet-stream":
        # Warning but continue
        pass

    # Generate APA citation
    model_name = (model_info or {}).get("model_name", "gpt-oss:120b")
    version = (model_info or {}).get("version", "2024")
    url = (model_info or {}).get("url", "https://ollama.com")
    citation = generate_apa_citation(model_name, version, url)

    # Save based on format
    # #region agent log
    write_instrumentation_log(
        location="DocuHelper.py:632",
        message="Before format save",
        data={"format": str(format), "citation_length": len(citation)},
        hypothesis_id="F",
    )
    # #endregion
    if format == DocumentFormat.TXT:
        return _save_as_txt(content, output_path, citation)
    if format == DocumentFormat.DOCX:
        return _save_as_docx(content, output_path, citation)
    if format == DocumentFormat.RTF:
        return _save_as_rtf(content, output_path, citation)
    if format == DocumentFormat.MD:
        return _save_as_md(content, output_path, citation)
    raise ValueError(f"Unsupported format: {format}")
